LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;

PACKAGE PKG_RGB_TYPES IS
	TYPE T_COLORES_RGB IS RECORD
		ROJO : STD_LOGIC_VECTOR(3 DOWNTO 0);
		VERDE : STD_LOGIC_VECTOR(3 DOWNTO 0);
		AZUL : STD_LOGIC_VECTOR(3 DOWNTO 0);
	END RECORD;
END PACKAGE PKG_RGB_TYPES;

LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.NUMERIC_STD.ALL;
USE WORK.PKG_RGB_TYPES.ALL;

ENTITY RGB_CONTROLADOR IS
	PORT (
		CLK_RGB : IN  STD_LOGIC;
		RST_RGB : IN  STD_LOGIC; -- RESET ACTIVO A NIVEL ALTO ('1')
		
		-- ENTRADAS
		BTN_UP, BTN_DOWN : IN  STD_LOGIC; 
		SW_RGB : IN  STD_LOGIC_VECTOR (3 DOWNTO 0); -- ROJO, VERDE, AZUL
		
		-- SALIDAS
		VALOR_SALIDA : OUT T_COLORES_RGB
	);
END RGB_CONTROLADOR;

ARCHITECTURE BEHAVIORAL OF RGB_CONTROLADOR IS

	-- DEFINICION DE LOS ESTADOS
	TYPE ESTADOS_T IS (S_REPOSO, S_SUBIR, S_BAJAR);
	SIGNAL ESTADO_ACTUAL : ESTADOS_T;
	SIGNAL ESTADO_SIGUIENTE : ESTADOS_T;

	-- REGISTROS INTERNOS
	SIGNAL R_REG : UNSIGNED(3 DOWNTO 0) := (OTHERS => '0');
	SIGNAL G_REG : UNSIGNED(3 DOWNTO 0) := (OTHERS => '0');
	SIGNAL B_REG : UNSIGNED(3 DOWNTO 0) := (OTHERS => '0');

BEGIN
    
    -- PROCESS 1: REGISTRO DE ESTADO Y MEMORIA (S√çNCRONO)
	REGISTRO_Y_DATOS: PROCESS (RST_RGB, CLK_RGB)
	BEGIN
		-- ESTADO 0:RESET PRIORITARIO
		    IF RST_RGB = '1' THEN 
			ESTADO_ACTUAL <= S_REPOSO;
			R_REG <= (OTHERS => '0');
			G_REG <= (OTHERS => '0');
			B_REG <= (OTHERS => '0');
			
		ELSIF RISING_EDGE(CLK_RGB) THEN
			-- ACTUALIZAMOS EL ESTADO
			ESTADO_ACTUAL <= ESTADO_SIGUIENTE;
			
			-- ESTADO 1: SUBIR
			IF ESTADO_ACTUAL = S_SUBIR THEN
				-- LOGICA ROJO
				IF SW_RGB(2) = '1' AND R_REG < "1111" THEN
					R_REG <= R_REG + 1;
				END IF;
				-- LOGICA VERDE
				IF SW_RGB(1) = '1' AND G_REG < "1111" THEN
					G_REG <= G_REG + 1;
				END IF;
				-- LOGICA AZUL
				IF SW_RGB(0) = '1' AND B_REG < "1111" THEN
					B_REG <= B_REG + 1;
				END IF;
			
			-- ESTADO 2: BAJAR
			ELSIF ESTADO_ACTUAL = S_BAJAR THEN
				-- LOGICA ROJO
				IF SW_RGB(2) = '1' AND R_REG > "0000" THEN
					R_REG <= R_REG - 1;
				END IF;
				-- LOGICA VERDE
				IF SW_RGB(1) = '1' AND G_REG > "0000" THEN
					G_REG <= G_REG - 1;
				END IF;
				-- LOGICA AZUL
				IF SW_RGB(0) = '1' AND B_REG > "0000" THEN
					B_REG <= B_REG - 1;
				END IF;
			END IF;
			
		END IF;
	END PROCESS;

	-- PROCESO 2: LOGICA DEL ESTADO SIGUIENTE (COMBINACIONAL)
	LOGICA_ESTADO_SIGUIENTE: PROCESS (ESTADO_ACTUAL, BTN_UP, BTN_DOWN)
	BEGIN
		-- ACTUALIZAMOS EL ESTADO
		ESTADO_SIGUIENTE <= ESTADO_ACTUAL;

		CASE ESTADO_ACTUAL IS
			
			-- ESTADO 0:RESET PRIORITARIO
			WHEN S_REPOSO =>
				IF BTN_UP = '1' THEN
					ESTADO_SIGUIENTE <= S_SUBIR; 
				ELSIF BTN_DOWN = '1' THEN
					ESTADO_SIGUIENTE <= S_BAJAR; 
				END IF;

			-- ESTADO 1: SUBIR
			WHEN S_SUBIR =>
				ESTADO_SIGUIENTE <= S_REPOSO; 

			-- ESTADO 2: BAJAR
			WHEN S_BAJAR =>
				ESTADO_SIGUIENTE <= S_REPOSO;

			-- SI PASA ALGO RARO, VOLVEMOS AL ESTADO REPOSO
			WHEN OTHERS =>
				ESTADO_SIGUIENTE <= S_REPOSO;
		END CASE;
	END PROCESS;

	-- PROCESO 3: DECODIFICADOR DE SALIDA (COMBINACIONAL)
	OUTPUT_DECOD: PROCESS (R_REG, G_REG, B_REG)
	BEGIN
		-- CONVERTIMOS LOS REGISTROS INTERNOS A CABLES DE SALIDA
		VALOR_SALIDA.ROJO  <= STD_LOGIC_VECTOR(R_REG);
		VALOR_SALIDA.VERDE <= STD_LOGIC_VECTOR(G_REG);
		VALOR_SALIDA.AZUL  <= STD_LOGIC_VECTOR(B_REG);
	END PROCESS;

END BEHAVIORAL;