LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;

-- 1. EL PAQUETE (MEJORADO 8 BITS => 2^8 = 256 COLORES)
PACKAGE PKG_RGB_TYPES IS
	TYPE T_COLORES_RGB IS RECORD
		ROJO  : STD_LOGIC_VECTOR(7 DOWNTO 0); 
		VERDE : STD_LOGIC_VECTOR(7 DOWNTO 0); 
		AZUL  : STD_LOGIC_VECTOR(7 DOWNTO 0); 
	END RECORD;
END PACKAGE PKG_RGB_TYPES;

LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.NUMERIC_STD.ALL;
USE WORK.PKG_RGB_TYPES.ALL;

ENTITY RGB_CONTROLADOR IS
	PORT (
		CLK_RGB : IN  STD_LOGIC;
		RST_RGB : IN  STD_LOGIC; 
		
		-- ENTRADAS
		BTN_UP, BTN_DOWN : IN  STD_LOGIC; 
		SW_RGB : IN  STD_LOGIC_VECTOR (3 DOWNTO 0); 
		
		-- SALIDAS (AHORA LLEVA 8 BITS POR COLOR)
		VALOR_SALIDA : OUT T_COLORES_RGB
	);
END RGB_CONTROLADOR;

ARCHITECTURE BEHAVIORAL OF RGB_CONTROLADOR IS

	-- DEFINICIÓN DE LOS ESTADOS
	TYPE ESTADOS_T IS (S_REPOSO, S_SUBIR, S_BAJAR);
	SIGNAL ESTADO_ACTUAL    : ESTADOS_T;
	SIGNAL ESTADO_SIGUIENTE : ESTADOS_T;

	-- REGISTROS INTERNOS (AHORA DE 8 BITS)
	SIGNAL R_REG : UNSIGNED(7 DOWNTO 0) := (OTHERS => '0');
	SIGNAL G_REG : UNSIGNED(7 DOWNTO 0) := (OTHERS => '0');
	SIGNAL B_REG : UNSIGNED(7 DOWNTO 0) := (OTHERS => '0');

BEGIN

	-- PROCESO 1: REGISTRO DE ESTADO Y DATOS (SÍNCRONO)
	REGISTRO_Y_DATOS: PROCESS (RST_RGB, CLK_RGB)
	BEGIN
		IF RST_RGB = '1' THEN 
			ESTADO_ACTUAL <= S_REPOSO;
			R_REG <= (OTHERS => '0');
			G_REG <= (OTHERS => '0');
			B_REG <= (OTHERS => '0');
			
		ELSIF RISING_EDGE(CLK_RGB) THEN
			ESTADO_ACTUAL <= ESTADO_SIGUIENTE;
			
			-- ESTADO 1: SUBIR (TOPE EN 255)
			IF ESTADO_ACTUAL = S_SUBIR THEN
				-- LOGICA ROJO
				IF SW_RGB(2) = '1' AND R_REG < 255 THEN
					R_REG <= R_REG + 1;
				END IF;
				-- LOGICA VERDE
				IF SW_RGB(1) = '1' AND G_REG < 255 THEN
					G_REG <= G_REG + 1;
				END IF;
				-- LOGICA AZUL
				IF SW_RGB(0) = '1' AND B_REG < 255 THEN
					B_REG <= B_REG + 1;
				END IF;
			
			-- ESTADO 2: BAJAR (SUELO EN 0)
			ELSIF ESTADO_ACTUAL = S_BAJAR THEN
				IF SW_RGB(2) = '1' AND R_REG > 0 THEN
					R_REG <= R_REG - 1;
				END IF;
				IF SW_RGB(1) = '1' AND G_REG > 0 THEN
					G_REG <= G_REG - 1;
				END IF;
				IF SW_RGB(0) = '1' AND B_REG > 0 THEN
					B_REG <= B_REG - 1;
				END IF;
			END IF;
		END IF;
	END PROCESS;

	-- PROCESO 2: LÓGICA DEL ESTADO SIGUIENTE (COMBINACIONAL)
	LOGICA_ESTADO_SIGUIENTE: PROCESS (ESTADO_ACTUAL, BTN_UP, BTN_DOWN)
	BEGIN
		ESTADO_SIGUIENTE <= ESTADO_ACTUAL;

		CASE ESTADO_ACTUAL IS
			WHEN S_REPOSO =>
				IF BTN_UP = '1' THEN
					ESTADO_SIGUIENTE <= S_SUBIR; 
				ELSIF BTN_DOWN = '1' THEN
					ESTADO_SIGUIENTE <= S_BAJAR; 
				END IF;
			WHEN S_SUBIR =>
				ESTADO_SIGUIENTE <= S_REPOSO; 
			WHEN S_BAJAR =>
				ESTADO_SIGUIENTE <= S_REPOSO;
			WHEN OTHERS =>
				ESTADO_SIGUIENTE <= S_REPOSO;
		END CASE;
	END PROCESS;

	-- PROCESO 3: SALIDA (DESEMPAQUETADO DEL RECORD)
	VALOR_SALIDA.ROJO  <= STD_LOGIC_VECTOR(R_REG);
	VALOR_SALIDA.VERDE <= STD_LOGIC_VECTOR(G_REG);
	VALOR_SALIDA.AZUL  <= STD_LOGIC_VECTOR(B_REG);

END BEHAVIORAL;